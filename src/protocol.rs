// This file is autogenerated. Do not edit.
// To make changes to this file, edit codegen.rb and/or codegen.erb and run make

use framing::{FrameType, Frame, MethodFrame};
use amqp_error::AMQPResult;

pub trait Method {
    fn decode(method_frame: MethodFrame) -> AMQPResult<Self> where Self: Sized;
    fn encode(&self) -> AMQPResult<Vec<u8>>;
    fn name(&self) -> &'static str;
    fn id(&self) -> u16;
    fn class_id(&self) -> u16;

    fn encode_method_frame(&self) -> AMQPResult<Vec<u8>> {
        let frame = MethodFrame {
            class_id: self.class_id(),
            method_id: self.id(),
            arguments: try!(self.encode()),
        };
        frame.encode()
    }

    fn to_frame(&self, channel: u16) -> AMQPResult<Frame> {
        Ok(Frame {
            frame_type: FrameType::METHOD,
            channel: channel,
            payload: try!(self.encode_method_frame()),
        })
    }
}


#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod connection {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:start
    method_struct!(Start, "connection.start", 10, 10,
        version_major => octet,
version_minor => octet,
server_properties => table,
mechanisms => longstr,
locales => longstr
    );

    unsafe impl Send for Start {}
    // Method 11:start-ok
    method_struct!(StartOk, "connection.start-ok", 10, 11,
        client_properties => table,
mechanism => shortstr,
response => longstr,
locale => shortstr
    );

    unsafe impl Send for StartOk {}
    // Method 20:secure
    method_struct!(Secure, "connection.secure", 10, 20,
        challenge => longstr
    );

    unsafe impl Send for Secure {}
    // Method 21:secure-ok
    method_struct!(SecureOk, "connection.secure-ok", 10, 21,
        response => longstr
    );

    unsafe impl Send for SecureOk {}
    // Method 30:tune
    method_struct!(Tune, "connection.tune", 10, 30,
        channel_max => short,
frame_max => long,
heartbeat => short
    );

    unsafe impl Send for Tune {}
    // Method 31:tune-ok
    method_struct!(TuneOk, "connection.tune-ok", 10, 31,
        channel_max => short,
frame_max => long,
heartbeat => short
    );

    unsafe impl Send for TuneOk {}
    // Method 40:open
    method_struct!(Open, "connection.open", 10, 40,
        virtual_host => shortstr,
capabilities => shortstr,
insist => bit
    );

    unsafe impl Send for Open {}
    // Method 41:open-ok
    method_struct!(OpenOk, "connection.open-ok", 10, 41,
        known_hosts => shortstr
    );

    unsafe impl Send for OpenOk {}
    // Method 50:close
    method_struct!(Close, "connection.close", 10, 50,
        reply_code => short,
reply_text => shortstr,
class_id => short,
method_id => short
    );

    unsafe impl Send for Close {}
    // Method 51:close-ok
    method_struct!(CloseOk, "connection.close-ok", 10, 51,

    );

    unsafe impl Send for CloseOk {}
    // Method 60:blocked
    method_struct!(Blocked, "connection.blocked", 10, 60,
        reason => shortstr
    );

    unsafe impl Send for Blocked {}
    // Method 61:unblocked
    method_struct!(Unblocked, "connection.unblocked", 10, 61,

    );

    unsafe impl Send for Unblocked {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod channel {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:open
    method_struct!(Open, "channel.open", 20, 10,
        out_of_band => shortstr
    );

    unsafe impl Send for Open {}
    // Method 11:open-ok
    method_struct!(OpenOk, "channel.open-ok", 20, 11,
        channel_id => longstr
    );

    unsafe impl Send for OpenOk {}
    // Method 20:flow
    method_struct!(Flow, "channel.flow", 20, 20,
        active => bit
    );

    unsafe impl Send for Flow {}
    // Method 21:flow-ok
    method_struct!(FlowOk, "channel.flow-ok", 20, 21,
        active => bit
    );

    unsafe impl Send for FlowOk {}
    // Method 40:close
    method_struct!(Close, "channel.close", 20, 40,
        reply_code => short,
reply_text => shortstr,
class_id => short,
method_id => short
    );

    unsafe impl Send for Close {}
    // Method 41:close-ok
    method_struct!(CloseOk, "channel.close-ok", 20, 41,

    );

    unsafe impl Send for CloseOk {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod access {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:request
    method_struct!(Request, "access.request", 30, 10,
        realm => shortstr,
exclusive => bit,
passive => bit,
active => bit,
write => bit,
read => bit
    );

    unsafe impl Send for Request {}
    // Method 11:request-ok
    method_struct!(RequestOk, "access.request-ok", 30, 11,
        ticket => short
    );

    unsafe impl Send for RequestOk {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod exchange {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:declare
    method_struct!(Declare, "exchange.declare", 40, 10,
        ticket => short,
exchange => shortstr,
_type => shortstr,
passive => bit,
durable => bit,
auto_delete => bit,
internal => bit,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Declare {}
    // Method 11:declare-ok
    method_struct!(DeclareOk, "exchange.declare-ok", 40, 11,

    );

    unsafe impl Send for DeclareOk {}
    // Method 20:delete
    method_struct!(Delete, "exchange.delete", 40, 20,
        ticket => short,
exchange => shortstr,
if_unused => bit,
nowait => bit
    );

    unsafe impl Send for Delete {}
    // Method 21:delete-ok
    method_struct!(DeleteOk, "exchange.delete-ok", 40, 21,

    );

    unsafe impl Send for DeleteOk {}
    // Method 30:bind
    method_struct!(Bind, "exchange.bind", 40, 30,
        ticket => short,
destination => shortstr,
source => shortstr,
routing_key => shortstr,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Bind {}
    // Method 31:bind-ok
    method_struct!(BindOk, "exchange.bind-ok", 40, 31,

    );

    unsafe impl Send for BindOk {}
    // Method 40:unbind
    method_struct!(Unbind, "exchange.unbind", 40, 40,
        ticket => short,
destination => shortstr,
source => shortstr,
routing_key => shortstr,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Unbind {}
    // Method 51:unbind-ok
    method_struct!(UnbindOk, "exchange.unbind-ok", 40, 51,

    );

    unsafe impl Send for UnbindOk {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod queue {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:declare
    method_struct!(Declare, "queue.declare", 50, 10,
        ticket => short,
queue => shortstr,
passive => bit,
durable => bit,
exclusive => bit,
auto_delete => bit,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Declare {}
    // Method 11:declare-ok
    method_struct!(DeclareOk, "queue.declare-ok", 50, 11,
        queue => shortstr,
message_count => long,
consumer_count => long
    );

    unsafe impl Send for DeclareOk {}
    // Method 20:bind
    method_struct!(Bind, "queue.bind", 50, 20,
        ticket => short,
queue => shortstr,
exchange => shortstr,
routing_key => shortstr,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Bind {}
    // Method 21:bind-ok
    method_struct!(BindOk, "queue.bind-ok", 50, 21,

    );

    unsafe impl Send for BindOk {}
    // Method 30:purge
    method_struct!(Purge, "queue.purge", 50, 30,
        ticket => short,
queue => shortstr,
nowait => bit
    );

    unsafe impl Send for Purge {}
    // Method 31:purge-ok
    method_struct!(PurgeOk, "queue.purge-ok", 50, 31,
        message_count => long
    );

    unsafe impl Send for PurgeOk {}
    // Method 40:delete
    method_struct!(Delete, "queue.delete", 50, 40,
        ticket => short,
queue => shortstr,
if_unused => bit,
if_empty => bit,
nowait => bit
    );

    unsafe impl Send for Delete {}
    // Method 41:delete-ok
    method_struct!(DeleteOk, "queue.delete-ok", 50, 41,
        message_count => long
    );

    unsafe impl Send for DeleteOk {}
    // Method 50:unbind
    method_struct!(Unbind, "queue.unbind", 50, 50,
        ticket => short,
queue => shortstr,
exchange => shortstr,
routing_key => shortstr,
arguments => table
    );

    unsafe impl Send for Unbind {}
    // Method 51:unbind-ok
    method_struct!(UnbindOk, "queue.unbind-ok", 50, 51,

    );

    unsafe impl Send for UnbindOk {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod basic {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};

    // properties struct for basic
    #[derive(Debug, Default, Clone)]
    pub struct BasicProperties {
        pub content_type: Option<String>,
        pub content_encoding: Option<String>,
        pub headers: Option<Table>,
        pub delivery_mode: Option<u8>,
        pub priority: Option<u8>,
        pub correlation_id: Option<String>,
        pub reply_to: Option<String>,
        pub expiration: Option<String>,
        pub message_id: Option<String>,
        pub timestamp: Option<u64>,
        pub _type: Option<String>,
        pub user_id: Option<String>,
        pub app_id: Option<String>,
        pub cluster_id: Option<String>,
    }

    impl BasicProperties {
        pub fn decode(content_header_frame: ContentHeaderFrame) -> AMQPResult<BasicProperties> {
            let reader = &mut &content_header_frame.properties[..];
            let properties_flags =
                BitVec::from_bytes(&[((content_header_frame.properties_flags >> 8) & 0xff) as u8,
                                     (content_header_frame.properties_flags & 0xff) as u8]);
            let content_type = match properties_flags.get(0) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let content_encoding = match properties_flags.get(1) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let headers = match properties_flags.get(2) {
                Some(flag) if flag => Some(try!(decode_table(reader)).0),
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let delivery_mode = match properties_flags.get(3) {
                Some(flag) if flag => Some(try!(reader.read_u8())),
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let priority = match properties_flags.get(4) {
                Some(flag) if flag => Some(try!(reader.read_u8())),
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let correlation_id = match properties_flags.get(5) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let reply_to = match properties_flags.get(6) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let expiration = match properties_flags.get(7) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let message_id = match properties_flags.get(8) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let timestamp = match properties_flags.get(9) {
                Some(flag) if flag => Some(try!(reader.read_u64::<BigEndian>())),
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let _type = match properties_flags.get(10) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let user_id = match properties_flags.get(11) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let app_id = match properties_flags.get(12) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            let cluster_id = match properties_flags.get(13) {
                Some(flag) if flag => {
                    Some({
                        let size = try!(reader.read_u8()) as usize;
                        let mut buffer: Vec<u8> = vec![0u8; size];
                        try!(reader.read(&mut buffer[..]));
                        String::from_utf8_lossy(&buffer[..]).to_string()
                    })
                }
                None => {
                    return Err(AMQPError::Protocol("Properties flags are not correct".to_owned()))
                }
                _ => None,
            };
            Ok(BasicProperties {
                content_type: content_type,
                content_encoding: content_encoding,
                headers: headers,
                delivery_mode: delivery_mode,
                priority: priority,
                correlation_id: correlation_id,
                reply_to: reply_to,
                expiration: expiration,
                message_id: message_id,
                timestamp: timestamp,
                _type: _type,
                user_id: user_id,
                app_id: app_id,
                cluster_id: cluster_id,
            })
        }

        pub fn encode(self) -> AMQPResult<Vec<u8>> {
            let mut writer = vec![];
            match self.content_type {
                Some(prop) => {
                    let content_type = prop;
                    try!(writer.write_u8(content_type.len() as u8));
                    try!(writer.write_all(content_type.as_bytes()));
                }
                None => {}
            };
            match self.content_encoding {
                Some(prop) => {
                    let content_encoding = prop;
                    try!(writer.write_u8(content_encoding.len() as u8));
                    try!(writer.write_all(content_encoding.as_bytes()));
                }
                None => {}
            };
            match self.headers {
                Some(prop) => {
                    let headers = prop;
                    try!(encode_table(&mut writer, &headers));
                }
                None => {}
            };
            match self.delivery_mode {
                Some(prop) => {
                    let delivery_mode = prop;
                    try!(writer.write_u8(delivery_mode));
                }
                None => {}
            };
            match self.priority {
                Some(prop) => {
                    let priority = prop;
                    try!(writer.write_u8(priority));
                }
                None => {}
            };
            match self.correlation_id {
                Some(prop) => {
                    let correlation_id = prop;
                    try!(writer.write_u8(correlation_id.len() as u8));
                    try!(writer.write_all(correlation_id.as_bytes()));
                }
                None => {}
            };
            match self.reply_to {
                Some(prop) => {
                    let reply_to = prop;
                    try!(writer.write_u8(reply_to.len() as u8));
                    try!(writer.write_all(reply_to.as_bytes()));
                }
                None => {}
            };
            match self.expiration {
                Some(prop) => {
                    let expiration = prop;
                    try!(writer.write_u8(expiration.len() as u8));
                    try!(writer.write_all(expiration.as_bytes()));
                }
                None => {}
            };
            match self.message_id {
                Some(prop) => {
                    let message_id = prop;
                    try!(writer.write_u8(message_id.len() as u8));
                    try!(writer.write_all(message_id.as_bytes()));
                }
                None => {}
            };
            match self.timestamp {
                Some(prop) => {
                    let timestamp = prop;
                    try!(writer.write_u64::<BigEndian>(timestamp));
                }
                None => {}
            };
            match self._type {
                Some(prop) => {
                    let _type = prop;
                    try!(writer.write_u8(_type.len() as u8));
                    try!(writer.write_all(_type.as_bytes()));
                }
                None => {}
            };
            match self.user_id {
                Some(prop) => {
                    let user_id = prop;
                    try!(writer.write_u8(user_id.len() as u8));
                    try!(writer.write_all(user_id.as_bytes()));
                }
                None => {}
            };
            match self.app_id {
                Some(prop) => {
                    let app_id = prop;
                    try!(writer.write_u8(app_id.len() as u8));
                    try!(writer.write_all(app_id.as_bytes()));
                }
                None => {}
            };
            match self.cluster_id {
                Some(prop) => {
                    let cluster_id = prop;
                    try!(writer.write_u8(cluster_id.len() as u8));
                    try!(writer.write_all(cluster_id.as_bytes()));
                }
                None => {}
            };
            Ok(writer)
        }

        pub fn flags(&self) -> u16 {
            let mut bits = BitVec::from_elem(16, false);
            bits.set(0, self.content_type.is_some());
            bits.set(1, self.content_encoding.is_some());
            bits.set(2, self.headers.is_some());
            bits.set(3, self.delivery_mode.is_some());
            bits.set(4, self.priority.is_some());
            bits.set(5, self.correlation_id.is_some());
            bits.set(6, self.reply_to.is_some());
            bits.set(7, self.expiration.is_some());
            bits.set(8, self.message_id.is_some());
            bits.set(9, self.timestamp.is_some());
            bits.set(10, self._type.is_some());
            bits.set(11, self.user_id.is_some());
            bits.set(12, self.app_id.is_some());
            bits.set(13, self.cluster_id.is_some());
            let flags: u16 = bits.to_bytes()[0] as u16;
            (flags << 8 | bits.to_bytes()[1] as u16) as u16
        }
    }

    // Method 10:qos
    method_struct!(Qos, "basic.qos", 60, 10,
        prefetch_size => long,
prefetch_count => short,
global => bit
    );

    unsafe impl Send for Qos {}
    // Method 11:qos-ok
    method_struct!(QosOk, "basic.qos-ok", 60, 11,

    );

    unsafe impl Send for QosOk {}
    // Method 20:consume
    method_struct!(Consume, "basic.consume", 60, 20,
        ticket => short,
queue => shortstr,
consumer_tag => shortstr,
no_local => bit,
no_ack => bit,
exclusive => bit,
nowait => bit,
arguments => table
    );

    unsafe impl Send for Consume {}
    // Method 21:consume-ok
    method_struct!(ConsumeOk, "basic.consume-ok", 60, 21,
        consumer_tag => shortstr
    );

    unsafe impl Send for ConsumeOk {}
    // Method 30:cancel
    method_struct!(Cancel, "basic.cancel", 60, 30,
        consumer_tag => shortstr,
nowait => bit
    );

    unsafe impl Send for Cancel {}
    // Method 31:cancel-ok
    method_struct!(CancelOk, "basic.cancel-ok", 60, 31,
        consumer_tag => shortstr
    );

    unsafe impl Send for CancelOk {}
    // Method 40:publish
    method_struct!(Publish, "basic.publish", 60, 40,
        ticket => short,
exchange => shortstr,
routing_key => shortstr,
mandatory => bit,
immediate => bit
    );

    unsafe impl Send for Publish {}
    // Method 50:return
    method_struct!(Return, "basic.return", 60, 50,
        reply_code => short,
reply_text => shortstr,
exchange => shortstr,
routing_key => shortstr
    );

    unsafe impl Send for Return {}
    // Method 60:deliver
    method_struct!(Deliver, "basic.deliver", 60, 60,
        consumer_tag => shortstr,
delivery_tag => longlong,
redelivered => bit,
exchange => shortstr,
routing_key => shortstr
    );

    unsafe impl Send for Deliver {}
    // Method 70:get
    method_struct!(Get, "basic.get", 60, 70,
        ticket => short,
queue => shortstr,
no_ack => bit
    );

    unsafe impl Send for Get {}
    // Method 71:get-ok
    method_struct!(GetOk, "basic.get-ok", 60, 71,
        delivery_tag => longlong,
redelivered => bit,
exchange => shortstr,
routing_key => shortstr,
message_count => long
    );

    unsafe impl Send for GetOk {}
    // Method 72:get-empty
    method_struct!(GetEmpty, "basic.get-empty", 60, 72,
        cluster_id => shortstr
    );

    unsafe impl Send for GetEmpty {}
    // Method 80:ack
    method_struct!(Ack, "basic.ack", 60, 80,
        delivery_tag => longlong,
multiple => bit
    );

    unsafe impl Send for Ack {}
    // Method 90:reject
    method_struct!(Reject, "basic.reject", 60, 90,
        delivery_tag => longlong,
requeue => bit
    );

    unsafe impl Send for Reject {}
    // Method 100:recover-async
    method_struct!(RecoverAsync, "basic.recover-async", 60, 100,
        requeue => bit
    );

    unsafe impl Send for RecoverAsync {}
    // Method 110:recover
    method_struct!(Recover, "basic.recover", 60, 110,
        requeue => bit
    );

    unsafe impl Send for Recover {}
    // Method 111:recover-ok
    method_struct!(RecoverOk, "basic.recover-ok", 60, 111,

    );

    unsafe impl Send for RecoverOk {}
    // Method 120:nack
    method_struct!(Nack, "basic.nack", 60, 120,
        delivery_tag => longlong,
multiple => bit,
requeue => bit
    );

    unsafe impl Send for Nack {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod tx {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:select
    method_struct!(Select, "tx.select", 90, 10,

    );

    unsafe impl Send for Select {}
    // Method 11:select-ok
    method_struct!(SelectOk, "tx.select-ok", 90, 11,

    );

    unsafe impl Send for SelectOk {}
    // Method 20:commit
    method_struct!(Commit, "tx.commit", 90, 20,

    );

    unsafe impl Send for Commit {}
    // Method 21:commit-ok
    method_struct!(CommitOk, "tx.commit-ok", 90, 21,

    );

    unsafe impl Send for CommitOk {}
    // Method 30:rollback
    method_struct!(Rollback, "tx.rollback", 90, 30,

    );

    unsafe impl Send for Rollback {}
    // Method 31:rollback-ok
    method_struct!(RollbackOk, "tx.rollback-ok", 90, 31,

    );

    unsafe impl Send for RollbackOk {}
}

#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod confirm {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};


    // Method 10:select
    method_struct!(Select, "confirm.select", 85, 10,
        nowait => bit
    );

    unsafe impl Send for Select {}
    // Method 11:select-ok
    method_struct!(SelectOk, "confirm.select-ok", 85, 11,

    );

    unsafe impl Send for SelectOk {}
}
